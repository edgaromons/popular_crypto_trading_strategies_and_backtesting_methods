# -*- coding: utf-8 -*-
"""

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TRzqYfLdarN9hzziOYuWhaF9m9tbEIPu

**Install Dependencies**
"""

"""**Import dependencies**"""

import os
import pandas as pd
import yfinance as yf
import alpaca as tradeapi
import alpaca_trade_api as tradeapi
import configparser
import pytz
import locale
import pandas_market_calendars as mcal

from alpaca_trade_api.rest import REST, TimeFrame, APIError
import alpaca_trade_api as alpaca
from ta.volatility import BollingerBands
from ta.momentum import RSIIndicator
from ta.trend import sma_indicator
from tqdm import tqdm
from requests_html import HTMLSession
from datetime import datetime
from slack import WebClient
from slack.errors import SlackApiError
import time
from alpaca.data.historical import CryptoHistoricalDataClient
from alpaca.data.requests import CryptoBarsRequest
from alpaca.data.timeframe import TimeFrame
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce
from datetime import datetime
from dateutil.relativedelta import relativedelta
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense, Dropout, LSTM
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error
import json
import logging
#import config
import asyncio
from lumibot.brokers import Alpaca
from lumibot.backtesting import YahooDataBacktesting
from lumibot.strategies.strategy import Strategy
from lumibot.traders import Trader
from datetime import datetime
from alpaca_trade_api import REST
#from timedelta import Timedelta
time.sleep(1)
from google.colab import drive
drive.mount('/content/drive')


"""**5 Popular Crypto Trading Strategies & How to Backtest**

Crypto day trading can involve various methods like chart analysis, technical indicators, sentiment analysis, and High-Frequency Trading. Given the crypto market’s unpredictability and volatility, backtesting trading strategies on historical data, before using them, can reinforce solid ideas and weed out weak ones.

Crypto day trading is the buying and selling of cryptocurrencies within the same day, to profit from short-term price fluctuations. Traders rely on technical analysis, make frequent trades, and manage risk to capitalize on market volatility. Generally, traders employ 4 hour, 1 hour, or even 15 minute time frames to inform their decisions. Utilizing higher time-frames to inform shorter time-frame moves or **backtesting their trading strategies** can help overcome the inherently myopic nature of day trading.

**5 Most Popular Crypto Trading Strategies**

**1. Technical Analysis**
The most popular crypto trading strategy is technical analysis, which can be broken down into two sections: chart analysis and technical indicators.

**a) Chart Analysis**

Chart analysis is the use of high time-frame chart patterns to analyze market movements and sentiment, understand trends, and inform trading decisions. This is commonly used by discretionary traders, and can be further divided into trend-following and mean-reverting strategies.

**Trend-following** assumes a persisting trend will break out of previously defined levels of resistance or support with sufficient momentum, and **mean-reverting** implies the price action is constrained by two eponymous levels, continuously reverting to some long-standing mean.

Chart analysis can involve the use of Japanese candlestick patterns. Popularized instruments include the Doji, the Mazuroba, the Spinning Top, the Hammer, amongst others. As the use of candlestick patterns is closely intertwined with market sentiment, **chart analysis traders will also utilize the Fear & Greed Index to factor in volatility, volume, social media craze, surveys, Bitcoin dominance, whale activity, and Google search trends. That said, some traders exclusively rely on crypto Twitter (CT), or may use it in conjunction with chart analysis, to inform trading decisions.**

**b) Technical Indicators**

The next prong of technical analysis is technical indicators. Like chart analysis, technical indicators also feature mean-reverting or trend-following strategies. To discern the two, one can employ the Augmented Dickey-Fuller (AFD) or Kwiatkowski–Phillips–Schmidt–Shin (KPSS) test. Both look for the existence of stationarity, allowing for traders to determine if mean-reversion is present. Both rely on the presumption that history will repeat itself, given that their inputs are historical price data.

While these tests are not necessary, it helps to explain the price action history. Traders can employ technical indicators to gain insight into the immediate future of the asset. Common indicators include:

Moving Averages
Moving Average Convergence Divergence (MACD)
Bollinger Bands
Average Directional Index (ADX)
Fibonacci Retracements
On-Balance Volume (OBV)
And others

Technical indicators are used by most market participants and remain prevalent today. For example, if you aim to comprehend the direction of public interest, consider examining the **Relative Strength Index (RSI)**. The RSI is widely recognized and utilized by retail traders for its popularity in capturing trends and market sentiment. Variations in trading success arise from a trader’s capacity to interpret the tool and deduce appropriate decisions.

**2. Options**

Most technical analysis tools are lagging indicators, slowing traders in their decision making and leaving them susceptible to sudden market changes. Given this gap, traders use other strategies like options trading, to mitigate risk.

Options trading gives the owner the right to buy or sell a predetermined quantity of the underlying asset at or before a certain strike date for a specified strike price. There are 3 type of option styles:

American: Contracts can be exercised at any time up to and including the day of expiry.

European: Contracts can only be exercised on the day of expiry.

Bermudan: Contracts can be exercised on a fixed set of dates.

European options are most commonly used in crypto. An options contract has inherent leverage, as one contract may represent multiple units of the underlying asset, and the downside is restricted to the premium one pays to hold the contract (when buying a put or call).

Therefore, traders will utilize puts and calls to manage their risk profile. One example is a long straddle. A long straddle consists of one long call of a higher strike price and one long put at a lower strike price. Both have the same underlying asset and strike date. This setup allows traders to capitalize if the underlying asset increases, or decreases in price. The loss is constrained to the premium and fees paid to hold the contract. Other risk-mitigating option strategies include:

Straddles
Butterflies
Married puts
Protective collars
And others

**3. High-Frequency Trading**

Alternatively, some traders utilize high-frequency trading – a technique that conducts many trades at once. It is a type of algorithmic trading strategy where computer programs execute a large number of trades in fractions of a second. They aim to anticipate market trends before they become apparent to other participants.

One example is market making. High-frequency traders will submit a limit order to buy or a limit offer to sell and earn the bid-ask spread. By setting their sell order a tad above asking, and their buy order a little below the current bid, they gain the difference in price. Other examples include:

Event Arbitrage
Statistical Arbitrage
Latency Arbitrage
Index Arbitrage

**4. Leading Signals**

Leading indicators are measurable signals that help forecast future price action activity, giving traders more insight in the present. The previously mentioned technical indicators have all been lagging signals as they confirm the data that is already apparent. Leading signals leave room for innovation. For instance, John Ehler often employed electrical engineering concepts, such as bandpass filters, to construct new indicators like the Fisher Transformation or the Empirical Mode Decomposition (EMD) tool.

The Fisher Transformation highlights when prices have moved to an extreme, based on recent data. It converts prices into a Gaussian Normal Distribution, highlighting peak swings and making price reversals easier to identify. This tool is an example of a leading indicator because it identifies potential price reversals before they occur.
Despite most technical indicators being lagging, John Ehlers innovations stand as a testament to the possibilities of creating new leading tools for this strategy.

**5. Perpetual Futures**

A perpetual future is a type of crypto derivative that allows users to speculate on the price of an asset. Perpetual futures are like futures contracts, but they do not have an expiry date. Therefore, their only purpose is speculation. When a perpetual contract is opened it has a fixed value, like a futures contract, but with no expiry, allowing traders to hold it indefinitely. Rather than settling the contract, ‘perps’ use funding rates. If the perp price is above the underlying asset spot price, traders who are long pay a fee to traders who are short – this is a positive funding rate. In contrast, if the funding rate is negative, traders who are short pay the traders who are long. This mechanism keeps the perp price inline with the spot price, as it becomes more expensive for traders to hold the contract the more it diverges.

This derivative is popular because it allows traders to utilize leverage, as some exchanges offer perps with extremely high leverage possibilities. They can be extremely risky, given their lack of regulation and potential for high significant fees.

**How to Backtest Your Crypto Trading Strategy**

In sum, trading encompasses the process of balancing risk with reward.

To backtest trading strategies, one will require historical crypto price data.

Backtesting is the process of applying a trading strategy over an asset's historical prices, ideally covering both bear and bull market scenarios, to evaluate its effectiveness prior to its actual implementation. Common metrics to measure effectiveness include the Sharpe ratio, the max drawdown, or the max drawdown duration.
"""

!pip install pycoingecko
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests
from datetime import datetime, timedelta
from pycoingecko import CoinGeckoAPI

"""**20-day SMA Strategy**

Let’s imagine we are constructing a strategy surrounding Ethereum for the past year.

To return OHLC data we will send a request to the CoinGeckoAPI to get_coin_ohlc_by_id, with inputs of ‘ethereum’, ‘usd’, and ‘365’.

Using the OHLC endpoint, the granularity of the data returns 4-hourly data
"""

cg = CoinGeckoAPI()
ohlc = cg.get_coin_ohlc_by_id(id='ethereum', vs_currency='usd', days='365')
df = pd.DataFrame(ohlc, columns=['date', 'open', 'high', 'low', 'close'])
df['date'] = pd.to_datetime(df['date'], unit='ms')
df.set_index('date', inplace=True)

# Let’s construct a simple strategy surrounding a 20-day simple moving average
 # (SMA). As the API returns data on 4-day intervals, our lookback period will
 # be 5, constructing a 20-day SMA.

# Display Price Action
plt.figure(figsize=(12, 6))
plt.plot(df['close'], label='Close Price (Price Action)', alpha=0.5)
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Ethereum Price Action Over Time & 20-Day SMA')

# Computing & Plotting SMA
lookback = 5
mean = df['close'].rolling(window=lookback).mean()
plt.plot(mean, label='20-Day SMA', alpha=0.5)
plt.legend(['ETH/USD', '20-DAY SMA'], loc='upper right')
plt.xticks(df.index[::10])
plt.show()

## Define the Strategy

# For this crypto trading strategy, we’ll assume a bullish signal is generated
# every time the price action crosses from below to above the 20-day SMA.
# Conversely a bearish signal is generated once the price action crosses from
# above to below the 20-day SMA. For this long-only strategy, we have just
# identified both entry and exit points.

df['SMA'] = df['close'].rolling(window=lookback).mean()
df['cross_up'] = (df['close'].shift(1) < df['SMA']) & (df['close'] > df['SMA'])
df['cross_down'] = (df['close'].shift(1) > df['SMA']) & (df['close'] < df['SMA'])

# generate our signals by adding a new ‘Signal’ series to our dataframe, where 1
# implies a long signal and -1 a short.
df['Signal'] = np.where(df['cross_up'], 1, np.where(df['cross_down'], -1, 0))

# Generating Results
# Our percentage returns can be calculated by taking the percentage change in
# the ‘close’ series and multiplying it by the shifted ‘Signal’ series. This is
# to align the signal generated with the corresponding close price.
# The cumulative returns are merely the cumulative product of the ‘Returns’ series.

# Returns
df['Returns'] = df['close'].pct_change()
df['Strategy Returns'] = df['Returns'] * df['Signal'].shift(1)
df['Cumulative Returns'] = (1 + df['Strategy Returns']).cumprod()

# Assess the Strategy
# max drawdown and max drawdown duration are two of the most common ways to
# assess a strategy using technical indicators.

def max_drawdown_duration():
    peak = df['Cumulative Returns'].cummax()
    drawdown = (df['Cumulative Returns'] - peak) / peak
    durations = []
    duration = 0
    for i in range(len(drawdown)):
        if drawdown.iloc[i] == 0:
           if duration > 0:
              durations.append(duration)
              duration = 0
        else:
            duration += 1
    max_duration = max(durations) if durations else 0
    return drawdown, max_duration

# Define Excess Returns and Sharpe Ratio
# The Sharpe ratio is calculated by taking the expected return and dividing it by
# the standard deviation of the excess returns. The expected return is simply the
# mean of our excess returns, which is the difference between the assets return
# and a risk-free asset. In this instance, we will disregard the risk-free rate.
# Our excess returns is a list, where each value is generated from our long and
# short signals. We will consider a long signal created when the ‘cross_up’ series
# is true because our ‘Signal’ series features a number of ‘1’s, due to them
# repeating until a short signal materializes. Only the first instance of each 1
# constitutes an entry signal, not each successive ‘1’. Each successive ‘1’ simply
# shows that we are still in a long position. Therefore, we use this alternative
# method as shown below.

excess_returns = []
for i in range(len(df['cross_up'])):
    if df['cross_up'][i]:
        excess_return = df['close'].pct_change()[i] * df['Signal'].shift(1)[i]
    elif df['Signal'][i] == -1:
        excess_return = df['close'].pct_change()[i] * df['Signal'].shift(1)[i]
    else:
        excess_return = 0
    excess_returns.append(excess_return)

# Analyzing Strategy Results

# Defining a strategy_result function amalgamates all previously discussed data
# to generate a signal output of consolidated figures. Similarly to our excess
# return function, we will define a long or ‘buy’ signal as the point where the
# ‘cross_up’ series is true, and the short or ‘sell’ signal where the ‘Signal’
# series is equal to -1.
# Then we can determine our profit, number of trades, and number of wins based on
# the discrepancy between the generated entry and exit prices.

def strategy_result(timeframe):
    waiting_for_close = False
    open_price = 0
    profit = 0
    wins = 0
    losses = 0

    for i in range(len(df.index) - 1):
        buy_signal = df.iloc[i]['cross_up']
        sell_signal = df.iloc[i]['Signal']

        if buy_signal == True and not waiting_for_close:
            waiting_for_close = True
            open_price = df.iloc[i+1]['open']
        elif sell_signal == -1 and waiting_for_close:
            waiting_for_close = False
            close_price = df.iloc[i+1]['open']

            profit += close_price - open_price
            if close_price > open_price:
                wins += 1
            else:
                losses += 1

    drawdown, max_duration = max_drawdown_duration()

    result_header = f' Result for {365} '.center(60, '-')
    profit_loss = f'-> Profit/Loss {profit:.2f}'
    num_trades = f"-> # of trades {((df['Signal'] == -1)).sum()}"
    buys_sells = f"-> Buys: {(df['cross_up'] == True).sum()} & Sells {(df['Signal'] == -1).sum()}"
    wins_losses = f"-> Wins {wins} - Losses: {losses}"
    trade_win_rate = f"-> Trade Win Rate {100 * (wins / (wins + losses)):5.2f}%"
    comprehensive_header = f' Result for  comprehensive Stats'.center(60, '-')
    avg_trade = f"-> Average Trade: {profit / ((df['Signal'] == -1).sum()):5.2f}"
    signal_returns = df['Returns'] * df['Signal'].shift(1)
    sharpe_ratio = np.mean(excess_returns) / np.std(excess_returns)
    sharpe_ratio_text = f'-> Sharpe Ratio {sharpe_ratio:.2f}'
    MDD = drawdown.min()
    max_drawdown = f'-> Max Drawdown {(MDD*100):5.2f}%'
    mdd_duration = f'-> MDD Duration {max_duration:5.2f} Periods'
    end_header = f' END '.center(60, '-')

    print(result_header)
    print(profit_loss)
    print(num_trades)
    print(buys_sells)
    print(wins_losses)
    print(trade_win_rate)
    print(comprehensive_header)
    print(avg_trade)
    print(sharpe_ratio_text)
    print(MDD)
    print(mdd_duration)
    print(end_header)

strategy_result(timeframe=365)

# Plot the Equity Curve
# Lastly, to conceptualize our max drawdown and MDD, by plotting the equity curve.

# Plotting the Equity Curve
plt.figure(figsize= (12, 6))
plt.plot(df.index, df['Cumulative Returns'], label = 'Equity Curve')
plt.xlabel('Date')
plt.ylabel('Cumulative Returns')
plt.title('Ethereum Equity Curve')
plt.legend(loc = 'upper right')
plt.xticks(df.index[::10])
plt.show()

# As demonstrated in our subsequent output below, our SMA crossover strategy
# for Ethereum over the past year generated negative results.
# This is epitomized by the low win rate, and negative sharpe ratio,
# suggesting this strategy would have been worse.

# As shown above, this 20-day SMA crossover strategy ultimately yielded negative
# returns over the course of a year.
